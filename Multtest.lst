     1                                  ; elementary multitasking of two threads
     2                                  [org 0x0100]
     3 00000000 E9A800                   jmp start
     4                                   ; ax,bx,ip,cs,flags storage area
     5 00000003 000000000000000000-     taskstates: dw 0, 0, 0, 0, 0 ; task0 regs
     5 0000000C 00                 
     6 0000000D 000000000000000000-      dw 0, 0, 0, 0, 0 ; task1 regs
     6 00000016 00                 
     7 00000017 000000000000000000-      dw 0, 0, 0, 0, 0 ; task2 regs
     7 00000020 00                 
     8 00000021 00                      current: db 0 ; index of current task
     9 00000022 5C7C2F2D                chars: db '\|/-' ; shapes to form a bar
    10                                  ; one task to be multitasked
    11 00000026 8A87[2200]              taskone: mov al, [chars+bx] ; read the next shape
    12 0000002A 26A20000                 mov [es:0], al ; write at top left of screen
    13 0000002E 43                        inc bx ; increment to next shape
    14 0000002F 83E303                   and bx, 3 ; taking modulus by 4
    15 00000032 EBF2                     jmp taskone ; infinite task
    16                                  ; second task to be multitasked
    17 00000034 8A87[2200]              tasktwo: mov al, [chars+bx] ; read the next shape
    18 00000038 26A29E00                 mov [es:158], al ; write at top right of screen
    19 0000003C 43                       inc bx ; increment to next shape
    20 0000003D 83E303                   and bx, 3 ; taking modulus by 4
    21 00000040 EBF2                     jmp tasktwo ; infinite task
    22                                  ; timer interrupt service routine
    23 00000042 50                      timer: push ax
    24 00000043 53                       push bx
    25 00000044 2E8A1E[2100]             mov bl, [cs:current] ; read index of current task
    26 00000049 B80A00                   mov ax, 10 ; space used by one task
    27 0000004C F6E3                     mul bl ; multiply to get start of task
    28 0000004E 89C3                     mov bx, ax ; load start of task in bx
    29 00000050 58                       pop ax ; read original value of bx
    30 00000051 2E8987[0500]             mov [cs:taskstates+bx+2], ax ; space for current task
    31 00000056 58                       pop ax ; read original value of ax
    32 00000057 2E8987[0300]             mov [cs:taskstates+bx+0], ax ; space for current task
    33 0000005C 58                       pop ax ; read original value of ip
    34 0000005D 2E8987[0700]             mov [cs:taskstates+bx+4], ax ; space for current task
    35 00000062 58                       pop ax ; read original value of cs
    36 00000063 2E8987[0900]             mov [cs:taskstates+bx+6], ax ; space for current task
    37 00000068 58                       pop ax ; read original value of flags
    38 00000069 2E8987[0B00]             mov [cs:taskstates+bx+8], ax ; space for current task
    39 0000006E 2EFE06[2100]             inc byte [cs:current] ; update current task index
    40 00000073 2E803E[2100]03           cmp byte [cs:current], 3 ; is task index out of range
    41 00000079 7506                     jne skipreset ; no, proceed
    42 0000007B 2EC606[2100]00           mov byte [cs:current], 0 ; yes, reset to task 0
    43 00000081 2E8A1E[2100]            skipreset: mov bl, [cs:current] ; read index of current task
    44 00000086 B80A00                   mov ax, 10 ; space used by one task
    45 00000089 F6E3                     mul bl ; multiply to get start of task
    46 0000008B 89C3                     mov bx, ax ; load start of task in bx
    47                                  
    48 0000008D B020                     mov al, 0x20
    49 0000008F E620                     out 0x20, al ; send EOI to PIC
    50 00000091 2EFFB7[0B00]             push word [cs:taskstates+bx+8] ; flags of new task
    51 00000096 2EFFB7[0900]             push word [cs:taskstates+bx+6] ; cs of new task
    52 0000009B 2EFFB7[0700]             push word [cs:taskstates+bx+4] ; ip of new task
    53 000000A0 2E8B87[0300]             mov ax, [cs:taskstates+bx+0] ; ax of new task
    54 000000A5 2E8B9F[0500]             mov bx, [cs:taskstates+bx+2] ; bx of new task
    55 000000AA CF                       iret ; return to new task
    56 000000AB C706[1100][2600]        start: mov word [taskstates+10+4], taskone ; initialize ip
    57 000000B1 8C0E[1300]               mov [taskstates+10+6], cs ; initialize cs
    58 000000B5 C706[1500]0002           mov word [taskstates+10+8], 0x0200 ; initialize flags
    59 000000BB C706[1B00][3400]         mov word [taskstates+20+4], tasktwo ; initialize ip
    60 000000C1 8C0E[1D00]               mov [taskstates+20+6], cs ; initialize cs
    61 000000C5 C706[1F00]0002           mov word [taskstates+20+8], 0x0200 ; initialize flags
    62 000000CB C706[2100]0000           mov word [current], 0 ; set current task index
    63 000000D1 31C0                     xor ax, ax
    64 000000D3 8EC0                     mov es, ax ; point es to IVT base
    65 000000D5 FA                       cli
    66 000000D6 26C7062000[4200]         mov word [es:8*4], timer
    67 000000DD 268C0E2200               mov [es:8*4+2], cs ; hook timer interrupt
    68 000000E2 B800B8                   mov ax, 0xb800
    69 000000E5 8EC0                     mov es, ax ; point es to video base
    70 000000E7 31DB                     xor bx, bx ; initialize bx for tasks
    71 000000E9 FB                       sti
    72 000000EA EBFE                     jmp $ ; infinite loop
